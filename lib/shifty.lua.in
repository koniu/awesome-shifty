--- Shifty: Dynamic tagging library for awesome3-git
-- @author koniu &lt;gkusnierz@gmail.com&gt;

-- todo:
--  more windowmatching with sizing and stuff + include scrollclient() / maybe separate module

-- package env

local tag = tag
local config = config
local ipairs = ipairs
local table = table
local client = client
local image = image
local hooks = hooks
local string = string
local widget = widget
local screen = screen
local button = button
local mouse = mouse
local capi = { hooks = hooks, client = client }
local beautiful = require("beautiful")
local awful = require("awful")
local image = image
local otable = otable

module("shifty")
local data = otable()

-- get tag by name
function name2tag(name, screen)
    local a, b = screen or 1, screen or screen.count()
    for s = a, b do
        for i, t in ipairs(tags[s]) do
            if name == t.name then
            return t end
        end
    end
end

-- get index by tag
function tag2index(tag)
    for i, t in ipairs(tags[tag.screen]) do
        if tag == t then return i end
    end
    return nil
end

function viewidx(i, screen)
    local tags = tags[screen]
    local sel = awful.tag.selected()
    awful.tag.viewnone()
    for k, t in ipairs(tags) do
        if t == sel then
            tags[awful.util.cycle(#tags, k + i)].selected = true
        end
    end
end

function tag_next(screen)
    local scr = screen or mouse.screen or 1
    local cur = awful.tag.selected(scr)
    viewidx(1, scr)
end

function tag_prev(screen)
    local scr = screen or mouse.screen or 1
    local cur = awful.tag.selected(scr)
    viewidx(-1, scr)
end

function tag_rename(tag)
    local scr = (t and t.screen) or mouse.screen or 1
    local t = tag or awful.tag.selected(scr)
    local bg = nil
    if t == awful.tag.selected(scr) then bg = beautiful.bg_focus or '#535d6c'
        else bg = beautiful.bg_normal or '#222222' end

    awful.prompt.run({
        fg_cursor = "orange",
        bg_cursor = bg,
        ul_cursor="single",
        prompt = '<bg color="'..bg..'" /> ' },
        taglist[scr][tag2index(t) * 2],
        function (name) if name:len() > 0 then t.name = name end end, nil,
        awful.util.getdir("cache") .. "/history_tags", nil, function () awful.hooks.user.call("tags", scr) end)
end

function tag_new()
    local t = tag_add({ name = 'new' })
    tag_rename(t)
end

function tag_send(idx)
    local scr = client.focus.screen or mouse.screen
    local cur = awful.tag.selected(scr)
    local curidx = tag2index(cur)
    local target = awful.util.cycle(#tags[scr], curidx + idx)
    awful.tag.viewonly(tags[scr][target])
    awful.client.movetotag(tags[scr][target], client.focus)
end

function tag_send_next() tag_send(1) end
function tag_send_prev() tag_send(-1) end

function tag_move(idx)
    local scr = mouse.screen or 1
    local cur = awful.tag.selected(scr)
    local curidx = tag2index(cur)
    local target = awful.util.cycle(#tags[scr], curidx + idx)
    table.remove(tags[scr], curidx)
    table.insert(tags[scr], target, cur)
    awful.hooks.user.call("tags", scr)
end

function tag_move_right() tag_move(1) end
function tag_move_left() tag_move(-1) end

function tag_add(args)
    local name = args.name or "__notext"
    local scr = args.screen or mouse.screen or 1
    local layout = args.layout or "max"
    local icon = args.icon
    local notext = args.notext
    local persist = args.persist
    local mwfact = args.mwfact
    local nmaster = args.nmaster
    local ncol = args.ncol
    for i,j in ipairs(config.tags) do
            if j.name == args.name then
                if not layout and j.layout then layout = j.layout end
                if not icon and j.icon then icon = j.icon end
                if not notext and j.notext then notext = true end
                if not persist and j.persist then persist = true end
                if not mwfact and j.mwfact then mwfact = j.mwfact end
                if not nmaster and j.nmaster then nmaster = j.nmaster end
                if not ncol and j.ncol then ncol = j.ncol end
                if not args.screen and j.screen then scr = j.screen end
            end
    end
    local pos = args.position or #tags[scr]+1
    local tag = tag({ name = name, layout = layout, nmaster = nmaster, mwfact = mwfact, ncol = ncol })
    data[tag] = {}
    data[tag].notext = notext
    data[tag].persist = persist
    if icon then data[tag].icon = image(icon) end
    table.insert(tags[scr], pos, tag)
    tags[scr][pos].screen = scr
    if #tags[scr] == 1 then awful.tag.viewonly(tag) end
    return tag
end

function tag_del(tag)
    local scr = (tag and tag.screen) or mouse.screen or 1
    local sel = awful.tag.selected(scr)
    local t = tag or sel
    table.remove(tags[scr], tag2index(t))
    data[t] = nil
    t.screen = nil
    if t == sel then awful.tag.history.restore(scr) end
end

function apptag(c)
    local cls = c.class
    local inst = c.instance
    local role = c.role
    local match = nil

    for i,a in ipairs(config.apps) do
        if a.match then
            for k,w in ipairs(a.match) do
                if
                    (role and role:find(w)) or
                    (inst and inst:find(w)) or
                    (cls and cls:find(w))
                then
                    match = true
                    if a.screen and a.screen ~= c.screen and a.screen <= screen.count()
                        then c.screen = a.screen end
                    if a.tag then
                        local target = name2tag(a.tag, c.screen) or tag_add({ name = a.tag, screen = c.screen })
                        awful.client.movetotag(target, c)
                        if not a.nopopup and target ~= awful.tag.selected(target.screen) then
                            awful.tag.viewonly(target)
                        end
                    end
                end
            end
        end
    end

    if not match and #tags[c.screen] == 0 then 
        local target = tag_add({ name = 'new', screen = c.screen })
        awful.client.movetotag(target, c)
        awful.tag.viewonly(target)
    end
end

function isoccupied(t)
    if not t or not t:clients() then return false end
    for c in ipairs(t:clients()) do return true end
    return false
end

function taglistlabel(t, args)
    if not args then args = {} end
    local fg_focus = args.fg_focus or beautiful.taglist_fg_focus or beautiful.fg_focus
    local bg_focus = args.bg_focus or beautiful.taglist_bg_focus or beautiful.bg_focus
    local fg_urgent = args.fg_urgent or beautiful.taglist_fg_urgent or beautiful.fg_urgent
    local bg_urgent = args.bg_urgent or beautiful.taglist_bg_urgent or beautiful.bg_urgent
    local taglist_squares_sel = args.squares_sel or beautiful.taglist_squares_sel
    local taglist_squares_unsel = args.squares_unsel or beautiful.taglist_squares_unsel
    local taglist_squares_resize = beautiful.taglist_squares_resize or args.squares_resize or "true"
    local text
    local background = ""
    local sel = capi.client.focus
    local bg_color = nil
    local fg_color = nil
    if t.selected then
        bg_color = bg_focus
        fg_color = fg_focus
    end
    if sel and sel:tags()[t] then
        if taglist_squares_sel then
            background = "resize=\"" .. taglist_squares_resize .. "\" image=\"" .. taglist_squares_sel .. "\""
        end
    else
        local cls = t:clients()
        if #cls > 0 and taglist_squares_unsel then
            background = "resize=\"" .. taglist_squares_resize .. "\" image=\"" .. taglist_squares_unsel .. "\""
        end
        for k, c in ipairs(cls) do
            if c.urgent then
                if bg_urgent then bg_color = bg_urgent end
                if fg_urgent then fg_color = fg_urgent end
                break
            end
        end
    end
    if bg_color and fg_color then
        text = "<bg "..background.." color='"..bg_color.."'/> <span color='"..awful.util.color_strip_alpha(fg_color).."'>"..awful.util.escape(t.name).."</span> "
    else
        text = " <bg "..background.." />"..awful.util.escape(t.name).." "
    end
    return text, bg_color
end

function taglistnew(scr, label, buttons)
    local w = {}
    local function taglist_update (screen)
        -- Return right now if we do not care about this screen
        if scr ~= screen then return end
        local tags = tags[screen]
        -- Hack: if it has been registered as a widget in a wibox,
        -- it's w.len since __len meta does not work on table until Lua 5.2.
        -- Otherwise it's standard #w.
        local len = (w.len or #w)/2
        -- Add more widgets
        if len < #tags then
            for i = 2*len + 1, 2*#tags, 2 do
                w[i] = widget({ type = "imagebox", name = "taglisti" .. i })
                w[i+1] = widget({ type = "textbox", name = "taglist" .. i })
            end
        -- Remove widgets
        elseif len > #tags then
            for i = 2*#tags + 1, 2*len, 2 do
                w[i] = nil
                w[i+1] = nil
            end
        end
        -- Update widgets text
        for k = 1, 2*#tags, 2 do
                local a, b = label(tags[(k+1)/2])
                if data[tags[(k+1)/2]] and data[tags[(k+1)/2]].icon then
                    w[k].image = data[tags[(k+1)/2]].icon
                    w[k].bg = b
                else
                    w[k].image = nil
                end
                if tags[(k+1)/2].name ~= "__notext" and not data[tags[(k+1)/2]].notext then
                    w[k+1].text = a
                else
                    w[k+1].text = ""
                end
            if buttons then
                -- Replace press function by a new one calling with tags as
                -- argument.
                -- This is done here because order of tags can change
                local mbuttons = {}
                for kb, b in ipairs(buttons) do
                    -- Copy object
                    mbuttons[kb] = button(b)
                    mbuttons[kb].press = function () b.press(tags[(k+1)/2]) end
                end
                w[k]:buttons(mbuttons)
                w[k+1]:buttons(mbuttons)
            end
        end
    end
    awful.hooks.arrange.register(taglist_update)
    awful.hooks.tags.register(taglist_update)
    awful.hooks.tagged.register(function (c, tag) taglist_update(c.screen) end)
    awful.hooks.property.register(function (c, prop)
        if c.screen == scr and prop == "urgent" then
            taglist_update(c.screen)
        end
    end)
    taglist_update(scr)
    return w
end

function killempty ()
    for s = 1, screen.count() do
        for i, j in ipairs(tags[s]) do
            if not isoccupied(j) and not data[j].persist then
                tag_del(j)
            end
        end
    end
end

awful.hooks.clients.register(killempty)
--awful.hooks.arrange.register(killempty)
awful.hooks.manage.register(apptag)


tags = {}

for s = 1, screen.count() do
    tags[s] = {}
end

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=80
