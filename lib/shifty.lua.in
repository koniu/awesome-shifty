--- Shifty: Dynamic tagging library for awesome3-git
-- @author koniu &lt;gkusnierz@gmail.com&gt;

-- todo:
--  multi-screen support
--  more windowmatching with sizing and stuff + include scrollclient() / maybe separate module
--  icon + text on tag
--  tag_add check for already existing tag names

-- package env

local print = print
local pairs = pairs
local freetags = freetags
local tag = tag
local config = config
local ipairs = ipairs
local table = table
local client = client
local wibox = wibox
local image = image
local awful = awful
local hooks = hooks
local string = string
local widget = widget
local screen = screen
local button = button
local capi = { screen = screen, hooks = hooks }
local beautiful = awful.beautiful.get()
--local tags = tags

module("shifty")



-- get tag by name
function name2tag(name)
	for s=1, screen.count() do
		for i,t in ipairs(tags[s]) do
			if name == t.name then 
			--print('name2tag tag', t); 
			return t end
		end	
	end
end

-- get index by tag
function tag2index(tag)
	for i,t in ipairs(tags[tag.screen]) do
		if tag == t then return i end
	end
	return nil
end

function history_back()
--	print('history back',history[#history].name)
	local set = nil
	repeat
	if history[#history].screen ~= nil and #history > 1 then
		awful.tag.viewonly(history[#history])
		table.remove(history,#history)
		set = true
	else
		table.remove(history,#history)
	end
	until set
end

function viewidx(i, screen)
    local tags = tags[screen]
    local sel = awful.tag.selected()
    awful.tag.viewnone()
    for k, t in ipairs(tags) do
        if t == sel then
            tags[awful.util.cycle(#tags, k + i)].selected = true
        end
    end
end


function tag_next() 
	local cur = awful.tag.selected(1)
	table.insert(history, cur)
	viewidx(1,1)
end

function tag_prev() 
	local cur = awful.tag.selected(1)
	table.insert(history, cur)
 	viewidx(-1,1)
end

function tag_rename(name, t)
	local t = t or awful.tag.selected(1)
	if name:len() > 0 then t.name = name end
	awful.hooks.user.call("tags", 1)
end

function tag_send(idx)
	local cur = awful.tag.selected(1)
	local curidx = tag2index(cur)
        local target = awful.util.cycle(#tags[1], curidx + idx)
	table.insert(history, cur)
	awful.tag.viewonly(tags[1][target])
	awful.client.movetotag(tags[1][target], client.focus)
end

function tag_send_next() tag_send(1) end
function tag_send_prev() tag_send(-1) end

function tag_move(idx)
	local cur = awful.tag.selected(1)
	local curidx = tag2index(cur)
        local target = awful.util.cycle(#tags[1], curidx + idx)
	table.remove(tags[1], curidx)
	table.insert(tags[1], target, cur)
	awful.hooks.user.call("tags", 1)
end

function tag_move_right() tag_move(1) end
function tag_move_left() tag_move(-1) end

function tag_add(name, position, layout)
	local pos = 0
	if not layout then 
		for i,j in pairs(config.tags) do 
			if j.name == name then 
				if j.layout then layout = j.layout end
			end
		end
	end
	if not layout then layout = "max" end
	pos = position or #tags[1]+1
	print('add: ', name, pos, layout)
	--print(pos)
	local tag = tag({name = name, layout = layout})
	--print(tag)
	table.insert(tags[1], pos, tag)
	tags[1][pos].screen = 1
	return tag
end

function tag_del(tag)
	local t = tag or awful.tag.selected(1)
	table.remove(tags[1], tag2index(t))
	t.screen = nil
	print('del: ', t.name, '#tags',#tags[1])
	if not tag then history_back() end
end


function apptag(c)
	    local cls = c.class
	    local inst = c.instance
	    local role = c.role

        for i,a in pairs(config.apps) do
	--print('apptag cli', c)
	--print('apptag tag', t.name, tag)
        if a.match then
                for k,w in pairs(a.match) do
                        if
                                (role and role:find(w)) or
                                (inst and inst:find(w)) or
                                (cls and cls:find(w))
                        then
				local target = name2tag(a.tag) or tag_add(a.tag)

                               	awful.client.movetotag(target,c)

                                if not a.nopopup and target ~= awful.tag.selected(1) then
					table.insert(history,awful.tag.selected(1))
					awful.tag.viewonly(target) 
                               	else 
					awful.client.urgent.add(c)
				end

                        end

                end
        end
        end
end

function isoccupied(t)
 	if not t or not t:clients() then return false end
 	for c in pairs(t:clients()) do return true end
	return false
end




function taglistnew(scr, label, buttons)
    local w = {}
    local function taglist_update (screen)
        -- Return right now if we do not care about this screen
        if scr ~= screen then return end
        local tags = tags[screen]
        -- Hack: if it has been registered as a widget in a wibox,
        -- it's w.len since __len meta does not work on table until Lua 5.2.
        -- Otherwise it's standard #w.
        local len = w.len or #w
        -- Add more widgets
        if len < #tags then
            for i = len + 1, #tags do
                w[i] = widget({ type = "textbox", name = "taglist" .. i })
            end
        -- Remove widgets
        elseif len > #tags then
            for i = #tags, len do
                w[i] = nil
            end
        end
        -- Update widgets text
        for k, tag in ipairs(tags) do
            w[k].text = label(tag)
            if buttons then
                -- Replace press function by a new one calling with tags as
                -- argument.
                -- This is done here because order of tags can change
                local mbuttons = {}
                for kb, b in ipairs(buttons) do
                    -- Copy object
                    mbuttons[kb] = button(b)
                    mbuttons[kb].press = function () b.press(tag) end
                end
                w[k]:buttons(mbuttons)
            end
        end
    end
    awful.hooks.arrange.register(taglist_update)
    awful.hooks.tags.register(taglist_update)
    awful.hooks.tagged.register(function (c, tag) taglist_update(c.screen) end)
    awful.hooks.property.register(function (c, prop)
        if c.screen == scr and prop == "urgent" then
            taglist_update(c.screen)
        end
    end)
    taglist_update(scr)
    return w
end



function killempty ()
	for i,j in pairs(tags[1]) do
		if not isoccupied(j) then 
			if j == awful.tag.selected(1) then history_back() end
			tag_del(j)
		end
	end
end

awful.hooks.clients.register(killempty)
--awful.hooks.arrange.register(killempty)
awful.hooks.manage.register(apptag)

tags = {}
tags[1] = {}
tag_add('sys')
history = {}
