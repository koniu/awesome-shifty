--- Shifty: Dynamic tagging library for awesome3-git
-- @author koniu &lt;gkusnierz@gmail.com&gt;

-- todo:
--  more windowmatching with sizing and stuff + include scrollclient() / maybe separate module
--  icon + text on tag

-- package env

local print = print
local pairs = pairs
local freetags = freetags
local tag = tag
local config = config
local ipairs = ipairs
local table = table
local client = client
local wibox = wibox
local image = image
local hooks = hooks
local string = string
local widget = widget
local screen = screen
local button = button
local mouse = mouse
local capi = { screen = screen, hooks = hooks }
local beautiful = require("beautiful")
local awful = require("awful")
local os = os
--local tags = tags

module("shifty")



-- get tag by name
function name2tag(name, screen)
    local a, b = screen or 1, screen or screen.count()
    for s = a, b do
        for i, t in ipairs(tags[s]) do
            if name == t.name then
            return t end
        end
    end
end

-- get index by tag
function tag2index(tag)
    for i, t in ipairs(tags[tag.screen]) do
        if tag == t then return i end
    end
    return nil
end

function viewidx(i, screen)
    local tags = tags[screen]
    local sel = awful.tag.selected()
    awful.tag.viewnone()
    for k, t in ipairs(tags) do
        if t == sel then
            tags[awful.util.cycle(#tags, k + i)].selected = true
        end
    end
end

function tag_next(screen)
    local scr = screen or mouse.screen or 1
    local cur = awful.tag.selected(scr)
    viewidx(1, scr)
end

function tag_prev(screen)
    local scr = screen or mouse.screen or 1
    local cur = awful.tag.selected(scr)
    viewidx(-1, scr)
end

function tag_rename(tag)
    local scr = (t and t.screen) or mouse.screen or 1
    local t = tag or awful.tag.selected(scr)
    local bg = nil
    if t == awful.tag.selected(scr) then bg = beautiful.bg_focus or '#535d6c'
        else bg = beautiful.bg_normal or '#222222' end

    awful.prompt.run({
        fg_cursor = "orange",
        bg_cursor = bg,
        ul_cursor="single",
        prompt = '<bg color="'..bg..'" /> ' },
        taglist[scr][tag2index(t)],
        function (name) if name:len() > 0 then t.name = name end end, nil,
        os.getenv("HOME") .. "/.cache/awesome/history_tags", nil, function () awful.hooks.user.call("tags", scr) end)
end

function tag_new()
    local t = tag_add('new')
    tag_rename(t)
end

function tag_send(idx)
    local scr = client.focus.screen or mouse.screen
    local cur = awful.tag.selected(scr)
    local curidx = tag2index(cur)
    local target = awful.util.cycle(#tags[scr], curidx + idx)
    awful.tag.viewonly(tags[scr][target])
    awful.client.movetotag(tags[scr][target], client.focus)
end

function tag_send_next() tag_send(1) end
function tag_send_prev() tag_send(-1) end

function tag_move(idx)
    local scr = mouse.screen or 1
    local cur = awful.tag.selected(scr)
    local curidx = tag2index(cur)
    local target = awful.util.cycle(#tags[scr], curidx + idx)
    table.remove(tags[scr], curidx)
    table.insert(tags[scr], target, cur)
    awful.hooks.user.call("tags", scr)
end

function tag_move_right() tag_move(1) end
function tag_move_left() tag_move(-1) end

function tag_add(name, screen, position, layout)
    local scr = screen or mouse.screen or 1
    local pos = position or #tags[scr]+1
    local layout = nil
    if not layout then
        for i,j in pairs(config.tags) do
            if j.name == name then
                if j.layout then layout = j.layout end
            end
        end
    end
    if not layout then layout = "max" end
    --print('add: ', name, pos, layout)

    local tag = tag({name = name, screen = scr, layout = layout})
    table.insert(tags[scr], pos, tag)
    tags[scr][pos].screen = scr
    if #tags[scr] == 1 then awful.tag.viewonly(tag) end
    return tag
end

function tag_del(tag)
    local scr = (tag and tag.screen) or mouse.screen or 1
    local sel = awful.tag.selected(scr)
    local t = tag or sel
    table.remove(tags[scr], tag2index(t))
    t.screen = nil
    if t == sel then awful.tag.history.restore(scr) end
end

function apptag(c)
    local cls = c.class
    local inst = c.instance
    local role = c.role
    local match = nil

    for i,a in pairs(config.apps) do
        if a.match then
            for k,w in pairs(a.match) do
                if
                    (role and role:find(w)) or
                    (inst and inst:find(w)) or
                    (cls and cls:find(w))
                then
                    match = true
                    if a.screen and a.screen ~= c.screen and a.screen <= screen.count()
                        then c.screen = a.screen end
                    if a.tag then
                        local target = name2tag(a.tag, c.screen) or tag_add(a.tag, c.screen)
                        awful.client.movetotag(target, c)
                        if not a.nopopup and target ~= awful.tag.selected(target.screen) then
                            awful.tag.viewonly(target)
                        else
                            awful.client.urgent.add(c)
                        end
                    end
                end
            end
        end
    end

    if not match and #tags[c.screen] == 0 then 
        local target = tag_add('new', c.screen)
        awful.client.movetotag(target, c)
        awful.tag.viewonly(target)
    end
end

function isoccupied(t)
    if not t or not t:clients() then return false end
    for c in pairs(t:clients()) do return true end
    return false
end

function taglistnew(scr, label, buttons)
    local w = {}
    local function taglist_update (screen)
        -- Return right now if we do not care about this screen
        if scr ~= screen then return end
        local tags = tags[screen]
        -- Hack: if it has been registered as a widget in a wibox,
        -- it's w.len since __len meta does not work on table until Lua 5.2.
        -- Otherwise it's standard #w.
        local len = w.len or #w
        -- Add more widgets
        if len < #tags then
            for i = len + 1, #tags do
                w[i] = widget({ type = "textbox", name = "taglist" .. i })
            end
        -- Remove widgets
        elseif len > #tags then
            for i = #tags, len do
                w[i] = nil
            end
        end
        -- Update widgets text
        for k, tag in ipairs(tags) do
            w[k].text = label(tag)
            if buttons then
                -- Replace press function by a new one calling with tags as
                -- argument.
                -- This is done here because order of tags can change
                local mbuttons = {}
                for kb, b in ipairs(buttons) do
                    -- Copy object
                    mbuttons[kb] = button(b)
                    mbuttons[kb].press = function () b.press(tag) end
                end
                w[k]:buttons(mbuttons)
            end
        end
    end
    awful.hooks.arrange.register(taglist_update)
    awful.hooks.tags.register(taglist_update)
    awful.hooks.tagged.register(function (c, tag) taglist_update(c.screen) end)
    awful.hooks.property.register(function (c, prop)
        if c.screen == scr and prop == "urgent" then
            taglist_update(c.screen)
        end
    end)
    taglist_update(scr)
    return w
end

function killempty ()
    for s = 1, screen.count() do
        for i, j in pairs(tags[s]) do
            if not isoccupied(j) then
                tag_del(j)
            end
        end
    end
end

awful.hooks.clients.register(killempty)
--awful.hooks.arrange.register(killempty)
awful.hooks.manage.register(apptag)


tags = {}

for s = 1, screen.count() do
    tags[s] = {}
end

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=80
