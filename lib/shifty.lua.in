--- Shifty: Dynamic tagging library for awesome3-git
-- @author koniu &lt;gkusnierz@gmail.com&gt;
--
-- http://awesome.naquadah.org/wiki/index.php?title=Shifty

-- package env

local tag = tag
local ipairs = ipairs
local table = table
local client = client
local image = image
local hooks = hooks
local string = string
local widget = widget
local screen = screen
local button = button
local mouse = mouse
local capi = { hooks = hooks, client = client }
local beautiful = require("beautiful")
local awful = require("awful")
local image = image
local otable = otable
local pairs = pairs

module("shifty")

tags = {}
config = {}
config.tags = {}
config.apps = {}
config.defaults = {}
config.guess = true
for s = 1, screen.count() do tags[s] = {} end
local data = otable()


function name2tag(name, scr)
    local a, b = scr or 1, scr or screen.count()
    for s = a, b do
        for i, t in ipairs(tags[s]) do
            if name == t.name then
            return t end
        end
    end
end

function tag2index(tag)
    for i, t in ipairs(tags[tag.screen]) do
        if tag == t then return i end
    end
end

function viewidx(i, screen)
    local screen = screen or mouse.screen or 1
    local tags = tags[screen]
    local sel = awful.tag.selected()
    awful.tag.viewnone()
    for k, t in ipairs(tags) do
        if t == sel then
            tags[awful.util.cycle(#tags, k + i)].selected = true
        end
    end
end

function next() viewidx(1) end
function prev() viewidx(-1) end

function rename(tag, prefix, no_selectall)
    local scr = mouse.screen or 1
    local t = tag or awful.tag.selected(scr)
    local bg = nil
    local text = prefix or t.name or ""
    if t == awful.tag.selected(scr) then bg = beautiful.bg_focus or '#535d6c'
        else bg = beautiful.bg_normal or '#222222' end

    awful.prompt.run({
        fg_cursor = "orange",
        bg_cursor = bg,
        ul_cursor="single",
        text = text,
        selectall = not no_selectall,
        prompt = '<bg color="'..bg..'" /> ' },
        taglist[scr][tag2index(t) * 2],
        function (name) if name:len() > 0 then t.name = name end end, nil,
        awful.util.getdir("cache") .. "/history_tags", nil, function () awful.hooks.user.call("tags", scr) end)
end

function send(idx)
    local scr = client.focus.screen or mouse.screen
    local sel = awful.tag.selected(scr)
    local sel_idx = tag2index(sel)
    local target = awful.util.cycle(#tags[scr], sel_idx + idx)
    awful.tag.viewonly(tags[scr][target])
    awful.client.movetotag(tags[scr][target], client.focus)
end

function send_next() send(1) end
function send_prev() send(-1) end

function shift(idx)
    local scr = mouse.screen or 1
    local sel = awful.tag.selected(scr)
    local sel_idx = tag2index(sel)
    local target = awful.util.cycle(#tags[scr], sel_idx + idx)
    table.remove(tags[scr], sel_idx)
    table.insert(tags[scr], target, sel)
    awful.hooks.user.call("tags", scr)
end

function shift_next() shift(1) end
function shift_prev() shift(-1) end

function add(args)
    if not args then args = {} end
    local name = args.name or ""
    local layout, icon, notext, persist, mwfact, nmaster, ncol, position, nopopup, leave_kills, idx, scr = nil
    local preset = config.tags[name] or {}

    layout = args.layout or preset.layout or config.defaults.layout
    icon = args.icon or preset.icon or config.defaults.icon
    notext = args.notext or preset.notext or config.defaults.notext
    persist = args.persist or preset.persist or config.defaults.persist
    mwfact = args.mwfact or preset.mwfact or config.defaults.mwfact
    nmaster = args.nmaster or preset.nmaster or config.defaults.nmaster
    ncol = args.ncol or preset.ncol or config.defaults.ncol
    scr = args.screen or preset.screen or mouse.screen or 1
    position = args.position or preset.position
    nopopup = args.nopopup or preset.nopopup or config.defaults.nopopup
    leave_kills = args.leave_kills or preset.leave_kills or config.defaults.leave_kills

    local tag = tag({ name = name, layout = layout, nmaster = nmaster, mwfact = mwfact, ncol = ncol })

    if position then
        for i, t in ipairs(tags[scr]) do
            if not data[t].position or data[t].position > position then
                idx = i
                break
            end
        end
    end
    if not idx then idx = #tags[scr] + 1 end

    data[tag] = {}
    data[tag].position = position
    data[tag].notext = notext
    data[tag].persist = persist
    data[tag].nopopup = nopopup
    data[tag].leave_kills = leave_kills
    data[tag].exclusive = preset.exclusive
    if icon then data[tag].icon = image(icon) end

    table.insert(tags[scr], idx, tag)
    tags[scr][idx].screen = scr
    if (not nopopup and not args.noswitch) or #tags[scr] == 1 then awful.tag.viewonly(tag) end
    if args.rename or name == "" then rename(tag, args.rename, args.no_selectall) end
    return tag
end

function del(tag)
    local scr = (tag and tag.screen) or mouse.screen or 1
    local sel = awful.tag.selected(scr)
    local t = tag or sel
    local idx = tag2index(t)
    if #(t:clients()) > 0 then return end
    table.remove(tags[scr], idx)
    data[t] = nil
    t.screen = nil
    if t == sel then
        awful.tag.history.restore(scr)
        if not awful.tag.selected(scr) then awful.tag.viewonly(tags[scr][awful.util.cycle(#tags[scr], idx - 1)])  end
    end
end

function match(c)
    local cls = c.class
    local inst = c.instance
    local role = c.role
    local name = nil
    local match = nil

    for i, a in ipairs(config.apps) do
        if a.match then
            for k, w in ipairs(a.match) do
                if
                    (role and role:find(w)) or
                    (inst and inst:find(w)) or
                    (cls and cls:find(w))
                then
                    match = true
                    if a.screen and a.screen ~= c.screen and a.screen <= screen.count()
                        then c.screen = a.screen end
                    if a.tag then
                        local target = name2tag(a.tag, c.screen) or add({ name = a.tag, screen = c.screen })
                        awful.client.movetotag(target, c)
                        if (not data[target].nopopup and not a.nopopup) and target ~= awful.tag.selected(target.screen) then
                            awful.tag.viewonly(target)
                        end
                    end
                end
            end
        end
    end

    if not match and (#tags[c.screen] == 0 or data[awful.tag.selected()].exclusive) then
        if config.guess and cls then name = cls:lower() else name = "new" end
        local target = add({ name = name, screen = c.screen })
        awful.client.movetotag(target, c)
        awful.tag.viewonly(target)
    end
end

function taglist_label(t, args)
    if not args then args = {} end
    local fg_focus = args.fg_focus or beautiful.taglist_fg_focus or beautiful.fg_focus
    local bg_focus = args.bg_focus or beautiful.taglist_bg_focus or beautiful.bg_focus
    local fg_urgent = args.fg_urgent or beautiful.taglist_fg_urgent or beautiful.fg_urgent
    local bg_urgent = args.bg_urgent or beautiful.taglist_bg_urgent or beautiful.bg_urgent
    local taglist_squares_sel = args.squares_sel or beautiful.taglist_squares_sel
    local taglist_squares_unsel = args.squares_unsel or beautiful.taglist_squares_unsel
    local taglist_squares_resize = beautiful.taglist_squares_resize or args.squares_resize or "true"
    local text
    local background = ""
    local sel = capi.client.focus
    local bg_color = nil
    local fg_color = nil
    if t.selected then
        bg_color = bg_focus
        fg_color = fg_focus
    end
    if sel and sel:tags()[t] then
        if taglist_squares_sel then
            background = "resize=\"" .. taglist_squares_resize .. "\" image=\"" .. taglist_squares_sel .. "\""
        end
    else
        local cls = t:clients()
        if #cls > 0 and taglist_squares_unsel then
            background = "resize=\"" .. taglist_squares_resize .. "\" image=\"" .. taglist_squares_unsel .. "\""
        end
        for k, c in ipairs(cls) do
            if c.urgent then
                if bg_urgent then bg_color = bg_urgent end
                if fg_urgent then fg_color = fg_urgent end
                break
            end
        end
    end
    if bg_color and fg_color then
        text = "<bg "..background.." color='"..bg_color.."'/> <span color='"..awful.util.color_strip_alpha(fg_color).."'>"..awful.util.escape(t.name).."</span> "
    else
        text = " <bg "..background.." />"..awful.util.escape(t.name).." "
    end
    return text, bg_color
end

function taglist_new(scr, label, buttons)
    local w = {}
    local function taglist_update (screen)
        -- Return right now if we do not care about this screen
        if scr ~= screen then return end
        local tags = tags[screen]
        -- Hack: if it has been registered as a widget in a wibox,
        -- it's w.len since __len meta does not work on table until Lua 5.2.
        -- Otherwise it's standard #w.
        local len = (w.len or #w)/2
        -- Add more widgets
        if len < #tags then
            for i = 2*len + 1, 2*#tags, 2 do
                w[i] = widget({ type = "imagebox", name = "taglisti" .. i })
                w[i+1] = widget({ type = "textbox", name = "taglist" .. i })
            end
        -- Remove widgets
        elseif len > #tags then
            for i = 2*#tags + 1, 2*len, 2 do
                w[i] = nil
                w[i+1] = nil
            end
        end
        -- Update widgets text
        for k = 1, 2*#tags, 2 do
                local a, b = label(tags[(k+1)/2])
                if data[tags[(k+1)/2]] and data[tags[(k+1)/2]].icon then
                    w[k].image = data[tags[(k+1)/2]].icon
                    w[k].bg = b
                else
                    w[k].image = nil
                end
                if not data[tags[(k+1)/2]].notext then
                    w[k+1].text = a
                else
                    w[k+1].text = ""
                end
            if buttons then
                -- Replace press function by a new one calling with tags as
                -- argument.
                -- This is done here because order of tags can change
                local mbuttons = {}
                for kb, b in ipairs(buttons) do
                    -- Copy object
                    mbuttons[kb] = button(b)
                    mbuttons[kb].press = function () b.press(tags[(k+1)/2]) end
                end
                w[k]:buttons(mbuttons)
                w[k+1]:buttons(mbuttons)
            end
        end
    end
    awful.hooks.arrange.register(taglist_update)
    awful.hooks.tags.register(taglist_update)
    awful.hooks.tagged.register(function (c, tag) taglist_update(c.screen) end)
    awful.hooks.property.register(function (c, prop)
        if c.screen == scr and prop == "urgent" then
            taglist_update(c.screen)
        end
    end)
    taglist_update(scr)
    return w
end

function sweep()
    for s = 1, screen.count() do
        for i, t in ipairs(tags[s]) do
            if #t:clients() == 0 then
                if not data[t].persist then
                    if data[t].deserted or (not data[t].leave_kills and data[t].used) then
                        del(t)
                    else
                        if not t.selected and data[t].visited then data[t].deserted = true end
                    end
                end
            else
                data[t].used = true
            end
            if t.selected then data[t].visited = true end
        end
    end
end

function getpos(pos, switch)
    local v = nil
    local scr = screen or mouse.screen or 1
    for t, d in pairs(data) do
        if t and d.position == pos then v = t end
    end
    if not v then
        for i, j in pairs(config.tags) do
            if j.position == pos then v = add({ name = i, screen = j.screen, noswitch = not switch }) end
        end
    end
    if not v then
        v = add({ position = pos, rename = pos .. ':', no_selectall = true, noswitch = not switch })
    end
    if switch then awful.tag.viewonly(v) end
    return v
end

function init()
    for i, j in pairs(config.tags) do
        if j.init then add({ name = i, persist = true, screen = j.screen }) end
    end
end

awful.hooks.tags.register(sweep)
awful.hooks.arrange.register(sweep)
awful.hooks.clients.register(sweep)
awful.hooks.manage.register(match)

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:encoding=utf-8:textwidth=80
